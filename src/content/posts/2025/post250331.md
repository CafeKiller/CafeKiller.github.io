---
title: 'JavaScript 优化方案'
pubDate: 2025-3-31 22:30:00
description: ''
author: 'CafeKiller'
image:
    url: ''
    alt: ''
tags: ["JavaScript"]
featured: false
class: '技术'
draft: false
---
分代假说认为大多数对象的生命周期非常短暂，即从垃圾回收的视角来看，大多数对象在被分配后几乎立即变成不可访问状态。这一规律不仅适用于 V8 或 JavaScript，对大多数动态语言都成立。

V8 的分代式堆内存布局正是基于这种对象生命周期特征而设计。堆内存被分为「年轻代」<small-text>（进一步划分为新生区和中间区两个子代）</small-text>和「老年代」。对象首先会被分配在「新生区」。如果它们在下一次垃圾回收中存活，就会被保留在年轻代但晋升为「中间区」状态。如果它们再次在垃圾回收中存活，就会晋升至老年代。

JavaScript 的垃圾回收算法分为两种：

- 次要垃圾回收：使用「Scavenger 算法」，回收年轻代中的垃圾
- 主要垃圾回收：使用「标记-清除算法」，回收老年代中的垃圾

# Scavenger 算法

V8 中的次要垃圾回收（Minor GC）正是基于分代假说，使用的是 Scavenger 算法。

它分为「标记」、「转移」和「指针更新」三个步骤：

- 标记（marking）：找到年轻代中的活跃对象
- 转移（evacuating）：将标记的对象复制到中间区或老年代（取决于是否已转移过）
- 指针更新（pointer-updating）：更新被复制对象的所有引用指针

**标记**

Scavenger 算法的第一步是找到年轻代中的活跃对象。这个类似于标记-清除算法中的标记阶段，需要从 GC Roots 开始，遍历完整个引用图，才能确定年轻代中哪些是存活的（其他的都是死亡的）。

GC Roots（根集合）是垃圾回收器进行可达性分析的起点，所有从 GC Roots 出发能直接或间接访问到的对象都被视为存活对象。GC Roots 主要包括以下内容：

- 全局对象：window、global
- 当前执行上下文中的活动对象：正在执行的函数内部的变量、闭包中引用的外部变量
- DOM 节点：所有未被移除的 DOM 元素的引用
- 活动线程和事件队列中的引用：setTimeout、Promise 回调中引用的对象、未解绑的事件监听器
- 内置对象和系统引用：当前正在执行的作用域链（Scope Chain）、内置对象（如 Math、JSON）的引用


**跨代引用列表**：根据分代假说，老年代中的对象大部分都是长期存活的，这意味本来只是为了找出年轻代中的活跃对象，结果却遍历了几乎整个老年代对象。  
为了避免遍历几乎整个老年代，V8 实现了一个机制，通过写屏障（Write Barrier）维护了一个「老年代对年轻代的跨代引用列表」（a list of old-to-new references）。然后从 GC Roots 开始遍历时，遇到老年代对象就直接跳过，仅遍历其中的年轻代对象，这样可以找到所有「从 GC Roots 出发，不经过老年代的年轻代」。接着再将跨代引用列表中的对象加入到 GC Roots 中遍历，同样是遇到老年代对象就直接跳过，这样就可以找到所有「被老年代引用的年轻代」。  
通过维护了一个「跨代引用列表」的方式，V8 不遍历老年代就能找到所有年轻代中的存活对象。

**写屏障**是一种在垃圾收集过程中用于保持对象引用完整性和一致性的重要技术。在 V8 引擎中，写屏障不仅在次要垃圾回收的标记阶段用于维护跨代引用列表，也在主要垃圾回收的并发标记和增量标记阶段用于更新存活的对象。  
写屏障在 js 执行写操作（比如 object.field = vaule）的时候会被触发，若一个对象更新了其引用信息，则会在写屏障中更新跨代引用列表。保证 Scavenger 算法的标记阶段能够获得准确的跨代引用信息。写屏障在并发标记和增量标记的应用将会在后续章节中介绍。