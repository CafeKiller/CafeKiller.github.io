---
title: 'Scavenger 算法'
pubDate: 2025-3-31 22:30:00
description: ''
author: 'CafeKiller'
image:
    url: ''
    alt: ''
tags: ["JavaScript"]
featured: false
class: '技术'
draft: false
---
分代假说认为大多数对象的生命周期非常短暂，即从垃圾回收的视角来看，大多数对象在被分配后几乎立即变成不可访问状态。这一规律不仅适用于 V8 或 JavaScript，对大多数动态语言都成立。

V8 的分代式堆内存布局正是基于这种对象生命周期特征而设计。堆内存被分为「年轻代」<small-text>（进一步划分为新生区和中间区两个子代）</small-text>和「老年代」。对象首先会被分配在「新生区」。如果它们在下一次垃圾回收中存活，就会被保留在年轻代但晋升为「中间区」状态。如果它们再次在垃圾回收中存活，就会晋升至老年代。

JavaScript 的垃圾回收算法分为两种：

- 次要垃圾回收：使用「Scavenger 算法」，回收年轻代中的垃圾
- 主要垃圾回收：使用「标记-清除算法」，回收老年代中的垃圾

# Scavenger 算法

V8 中的次要垃圾回收（Minor GC）正是基于分代假说，使用的是 Scavenger 算法。

它分为「标记」、「转移」和「指针更新」三个步骤：

- 标记（marking）：找到年轻代中的活跃对象
- 转移（evacuating）：将标记的对象复制到中间区或老年代<small-text>（取决于是否已转移过）</small-text>
- 指针更新（pointer-updating）：更新被复制对象的所有引用指针

## 标记

Scavenger 算法的第一步是找到年轻代中的活跃对象。这个类似于标记-清除算法中的标记阶段，需要从 GC Roots 开始，遍历完整个引用图，才能确定年轻代中哪些是存活的<small-text>（其他的都是死亡的）</small-text>。

**GC Roots**：根集合，是垃圾回收器进行可达性分析的起点，所有从 GC Roots 出发能直接或间接访问到的对象都被视为存活对象。GC Roots 主要包括以下内容：

- 全局对象：window、global
- 当前执行上下文中的活动对象：正在执行的函数内部的变量、闭包中引用的外部变量
- DOM 节点：所有未被移除的 DOM 元素的引用
- 活动线程和事件队列中的引用：setTimeout、Promise 回调中引用的对象、未解绑的事件监听器
- 内置对象和系统引用：当前正在执行的作用域链<small-text>（Scope Chain）</small-text>、内置对象<small-text>（如 Math、JSON）</small-text>的引用

**跨代引用列表**：根据分代假说，老年代中的对象大部分都是长期存活的，这意味本来只是为了找出年轻代中的活跃对象，结果却遍历了几乎整个老年代对象。  
为了避免遍历几乎整个老年代，V8 实现了一个机制，通过写屏障（Write Barrier）维护了一个「老年代对年轻代的跨代引用列表」（a list of old-to-new references）。然后从 GC Roots 开始遍历时，遇到老年代对象就直接跳过，仅遍历其中的年轻代对象，这样可以找到所有「从 GC Roots 出发，不经过老年代的年轻代」。接着再将跨代引用列表中的对象加入到 GC Roots 中遍历，同样是遇到老年代对象就直接跳过，这样就可以找到所有「被老年代引用的年轻代」。  
通过维护了一个「跨代引用列表」的方式，V8 不遍历老年代就能找到所有年轻代中的存活对象。

**写屏障**：是一种在垃圾收集过程中用于保持对象引用完整性和一致性的重要技术。在 V8 引擎中，写屏障不仅在次要垃圾回收的标记阶段用于维护跨代引用列表，也在主要垃圾回收的并发标记和增量标记阶段用于更新存活的对象。  
写屏障在 js 执行写操作（比如 object.field = vaule）的时候会被触发，若一个对象更新了其引用信息，则会在写屏障中更新跨代引用列表。保证 Scavenger 算法的标记阶段能够获得准确的跨代引用信息。写屏障在并发标记和增量标记的应用将会在后续章节中介绍。

## 转移

Scavenger 算法的第二步是将标记的对象复制到中间区或老年代（取决于是否已转移过一次）。

复制（转移）是垃圾回收中开销非常大的操作。不过根据分代假说，年轻代中实际存活的对象比例极低，需要复制的对象也很少。通过仅移动存活对象，其他所有内存都成为了可回收的垃圾。这意味着我们只需承担与存活对象数量成正比（而非与总分配量成正比）的复制成本。

**半空间**：在针对年轻代的回收过程中，存活的对象始终会被转移到新的内存页。V8 为年轻代采用了半空间（Semi-Space）设计，这意味着总空间的一半始终预留为空，以支持转移操作。  
在回收期间，初始为空的部分称为 To-Space，而需要复制的来源区域称为 From-Space。转移步骤会将所有存活对象移动到连续的内存块中（位于同一内存页内），从而完全消除内存碎片（即死对象留下的间隙）。  
随后会交换两个半空间的角色——To-Space 变为From-Space，From-Space 变为 To-Space。垃圾回收完成后，新对象的内存分配将从新的 From-Space 的下一个空闲地址开始。  
下一次垃圾回收时，From-Space 中刚分配的对象会被转移到 To-Space，而 From-Space 中已经移动过一次的对象则会被转移到老年代。

## 指针更新

Scavenger 算法的最后一步是更新引用地址。注意无论对象是第一次转移（从 From-Space 到 To-Space），还是第二次转移（从 From-Space 到老年代），都会在原来的位置留下一个转发地址，用于更新原始指针的地址。

接下来 V8 需要知道内存中哪些地方引用了这次转移的对象，更新它们的指针。那么如何找到所有引用了这些对象的对象呢？由于对象的引用是单向的关系，似乎只能重新完全遍历一次所有内存，才能找到引用了该对象的对象。这肯定是不现实的，它会非常慢。所以 V8 引入了存储缓冲区，将对象的引用关系由单向变成了双向的，解决了「如何找到引用了该对象的对象」这个问题。

**存储缓冲区**：V8 在内存中每个对象建立引用关系时，反向记录了一个地址，指向了引用该对象的对象，使得对象的引用关系就不是单向的了，而是双向的。这个信息就存储在「存储缓冲区」（Store Buffer）中。  

**记忆集**：为了解决多线程并行执行指针更新时的数据竞争问题，V8 使用了「记忆集」（Remembered Set）替代「存储缓冲区」来记录对象的引用关系。  

## 并行

并行（Parallel）是将垃圾回收任务分配给多个线程并行执行，但它仍然会阻塞主线程（GC Stop-The-World），只是相对来说阻塞的时间变少了。

并发（Concurrent）则是将任务完全交给其他线程，完全不阻塞主线程。

并行是一种相对简单的技术，因为主线程的 js 已经暂停了，不会再修改内存。只需要确保多个线程访问同一个对象时能得到及时的同步。而并发则是比较困难的技术，因为 js 主线程可能随时读写内存，使得垃圾回收中的标记任务变得无效，还需担心主线程和辅助线程读写同一个对象时造成的数据竞争。

次要垃圾回收时，因为只需要扫描年轻代内存，所以标记阶段耗时很小。大部分耗时都在转移阶段，而转移阶段是无法并发的——转移阶段肯定不能让主线程继续执行 js。次要垃圾回收只能在标记和指针更新阶段引入并发，带来的性能提升很小，反而还增加了写屏障、线程同步等耗时，得不偿失。所以次要垃圾回收只使用了并行技术。

在 v6.2 之前，V8 的次要垃圾回收使用的是一种没有并行技术的「单线程 Cheney 半空间复制算法」（Single-threaded Cheney’s Semispace Copy）。这种算法其实就是前文中介绍 Scavenger 算法中不包含并行的部分，它简单易实现，适合单核环境，但也会完全阻塞主线程，没有利用到多核的性能优势。