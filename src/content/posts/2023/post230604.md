---
title: 'MySQL 索引相关'
pubDate: 2023-06-04 12:00:00
description: '最近我也刚好在复习 MySQL 索引相关的知识，发现这个东西涉及的知识面和深度都挺大的，所以打算写篇博客记录一下'
author: 'CafeKiller'
image:
    url: ''
    alt: ''
tags: ["MySQL"]
class: '技术'
---

索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。

索引的作用就相当于一本书的目录。就像一本新华字典，我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。但是有目录了，我们只需要先去目录里查找字的大概位置，然后直接翻到对应那页就可以了。

# 索引的数据结构

索引底层数据结构有很多种类型：`B 树`、`B+ 树`、`Hash 树`、`红黑树`。MySQL 中的存储引擎采用的就是：**B+ 树**。

B+ 树是大多数 MySQL 存储引擎的默认索引类型。因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。可以指定多个列作为索引列，多个索引列共同组成键。适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

B 树也称 B-树,全称为 多路平衡查找树 ，B+树 是 B树 的一种变体。B树 和 B+树 中的 「B」 是 Balanced <small-text>（平衡）</small-text>的意思。

> **B树和B+树的差异**
>
> - B树的所有节点既存放键(key) 也存放数据(data)，而B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
> - B树的叶子节点都是独立的；B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
> - B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。
> - 在B树中进行范围查询时，首先找到要查找的下限，然后对B树进行中序遍历，直到找到查找的上限；而B+树的范围查询，只需要对链表进行遍历即可。
>
> 综上，B+树与B树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。

MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为「**非聚簇索引 / 非聚集索引**」。

InnoDB 引擎的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为「**聚簇索引**」。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

## 为何是B+树

索引的底层数据结构虽然有很多种，但为何只采用了B+树呢？它对比其他数据结构有什么优秀和独到之处。

**Hash 表**

哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 `O（1）`）。

但是，哈希表存在一个哈希冲突问题。为了减少 Hash 冲突的发生，一个好的哈希函数应该「均匀地」将数据分布在整个可能的哈希值集合中。

InnoDB 存储引擎有一个特殊的功能叫 「自适应哈希索引」，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

Hash 索引虽然速度快，但不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引就不行了。

**BST 树**

二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，有这些特点：1、左子树所有节点的值均小于根节点的值；2、右子树所有节点的值均大于根节点的值；3、左右子树也分别为二叉查找树。

当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 `O(log2(N))`，具有比较高的效率。然而，当二叉查找树不平衡时，例如在最坏情况下<small-text>（有序插入节点）</small-text>，树会退化成线性链表<small-text>（此时也被称为斜树）</small-text>，导致查询效率急剧下降，时间复杂退化为 `O（N）`。

也就是说，二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。

> B树和B+树其实就是基于二叉树的改进。

**AVL树**

AVL 树是计算机科学中最早被发明的自平衡二叉查找树。AVL 树的特点是保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 `O(logn)`。

但由于 AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能。并且，在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。

**红黑树**

红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态。

它的特点是：
- 每个节点非红即黑；
- 根节点总是黑色的；
- 每个叶子节点都是黑色的空节点<small-text>（NIL 节点）</small-text>；
- 如果节点是红色的，则它的子节点必须是黑色的<small-text>（反之不一定）</small-text>；
- 从任意节点到它的叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点<small-text>（即相同的黑色高度）</small-text>。

和 AVL 树不同的是，红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。  
也正因如此，红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 `O(1)` 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 **O(logn)** 次数的旋转操作。

> 红黑树的应用相当广泛，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。

# 正确使用索引的建议

**选择合适的字段创建索引**

- 不为 NULL 的字段：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段**：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段**：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段**：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段**：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

**被频繁更新的字段应该慎重建立索引**

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

**限制每张表上的索引数量**

索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。

因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能

**尽可能的考虑建立联合索引而不是单列索引**

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

**注意避免冗余索引**

冗余索引指的是索引的功能相同，能够命中索引 `(a, b)` 就肯定能命中索引 (a) ，那么索引(a) 就是冗余索引。如 `（name,city ）和（name ）` 这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。