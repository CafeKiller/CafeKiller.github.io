---
title: '闭包机制'
pubDate: 2023-04-29 12:00:00
description: '闭包，即有权访问另一个函数作用域中的变量的函数；一般情况就是在一个函数中包含另一个函数。'
author: 'CafeKiller'
image:
    url: ''
    alt: ''
tags: ["前端", "JavaScript"]
class: '技术'
---

首先我们都知道，函数作用域是独立的、封闭的，外部的执行环境是访问不了的，但是闭包具有这个能力和权限。  
在 JavaScript 中变量的作用域无非两种，「全局作用域」和「局部作用域」，JavaScript 语言的一个特性就是：函数内部可以直接读取全局变量，而函数外部正常是无法读取函数内的局部变量。

目前各类文献中关于「闭包」的解释都五花八门，且不少都晦涩难懂。我个人理解的闭包表现显示就是：**闭包是一个函数，而且存在于另一个函数当中；闭包可以访问到父级函数的变量，且该变量不会销毁**。

> JavaScript 闭包的实现原理，其实是利用了作用域链的特性，因为 JavaScript 的作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。

# 闭包作用

闭包的主要作用有：允许读取函数内部的变量、可以让这些变量的值始终保持在内存中、隐藏变量避免全局污染。

```javascript
var a  = 10; // 防止全局污染
function Add(){
    var a = 10; // 始终保存在内存中
    return function(){
        a++;
        return a; // 读取函数内部变量
    };
};
var addF = Add();
console.log(addF()); // 11
console.log(addF()); // 12
console.log(addF()); // 13
console.log(a);      // 10
```

但闭包也是存在风险的，使用不当的情况下优点可能也会变缺点：

1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象<small-text>（object）</small-text>使用，把闭包当作它的公用方法<small-text>（Public Method）</small-text>，把内部变量当作它的私有属性<small-text>（private value）</small-text>，这时一定要小心，不要随便改变父函数内部变量的值。

> **在特定的情况下，闭包中的变量可能不会被垃圾回收**  
> 首先明确一个点，如果闭包函数的引用计数为 0 时，函数就会释放，它引用的变量也会被释放。  
> 只有当闭包函数的引用计数不为 0 时，说明闭包函数随时有可能被调用，他被调用后，就会引用他在定义时所处的环境的变量。闭包中的变量就得一直需要在内存中，则就不会被垃圾回收掉。

<!-- # 扩展

闭包机制广泛的应用在各类编程语言中，虽然他们在核心原理是基本相似的，但在具体的实现和使用方式上会有一定差异。

> 核心原理：一个函数能够捕获并保存其外部作用域中的变量，即使外部作用域已经结束，这些变量仍然可以被访问。
>
> 关键特性：
> - 词法作用域：闭包依赖于词法作用域，即函数在定义时所处的作用域，而不是调用时的作用域。
> - 环境保存：闭包会保存其外部作用域的引用，使得外部变量不会被垃圾回收。

**Python 闭包机制**

Python 的闭包是基于嵌套函数和作用域规则实现的。和 JavaScript 是基本类似的。

但 Python 闭包会保存外部函数的变量，但这些变量默认是只读的。如果需要修改外部变量，必须使用 `nonlocal` 或者 `global` 关键字显式声明。

```python
def make_averager():
    series = []
    
    def averager(new_value):
        series.append(new_value)
        total = sum(series)
        return total / len(series)

    return averager

avg = make_averager()
avg = avg(10) # 10
avg = avg(20) # 15
avg = avg(30) # 20
```

# 后记

这篇 Blog 其实一开始是不想写的，只是作为我个人的简单笔记使用的，因为就单一个 JavaScript 的闭包机制，其实也没啥好聊的，多数学习前端的同学也基本了解不需要我这个文笔糟糕的家伙再解释啥了，而且闭包机制已经相当成熟了，也没更新什么新玩法内容也不多。只是后来接触到了其他语言的闭包机制，了解的多了，才觉得可以适当写篇 Blog 记录一下。 
-->

## 参考链接

[阮一峰 - 学习Javascript闭包（Closure）](https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)

[思否 - 深入理解JavaScript闭包](https://segmentfault.com/a/1190000023356598)

[知乎 - JavaScript中闭包的概念、原理、作用及应用](https://zhuanlan.zhihu.com/p/106287246)